

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Algorithms &#8212; Qiskit Aqua 0.4.0 documentation</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <script type="text/javascript" src="_static/bootstrap.min.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Optimizers" href="optimizers.html" />
    <link rel="prev" title="Contributing to Aqua" href="extending.html" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<!--[if lt IE 9]>
    <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
<div id="head" class="head">
    <a href="https://qiskit.org/aqua">Qiskit Aqua</a>
</div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="optimizers.html" title="Optimizers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="extending.html" title="Contributing to Aqua"
             accesskey="P">previous</a> |</li>
<li id="toc-toggle">
<a class="btn btn-primary" role="button" data-toggle="collapse"
   href=".sphinxsidebar" aria-expanded="false" aria-controls="collapseExample">
  TOC</a> |
</li>

        <li class="nav-item nav-item-0"><a href="index.html">Qiskit Aqua 0.4.0 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="aqua.html" >Qiskit Aqua</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="library.html" accesskey="U">Aqua: A Library of Quantum Algorithms</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/qiskit-logo-white-no-margin.gif" alt="Logo"/>
            </a></p>
<p class="logo-description">Qiskit Aqua</p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="aqua.html">Qiskit Aqua</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="library.html">Aqua: A Library of Quantum Algorithms</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html">Installation and Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="execution.html">Configuring and Running an Experiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="extending.html">Contributing to Aqua</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quantum-algorithms">Quantum Algorithms</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#variational-quantum-eigensolver-vqe">Variational Quantum Eigensolver (VQE)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#quantum-approximate-optimization-algorithm-qaoa">Quantum Approximate Optimization Algorithm (QAOA)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#evolution-of-hamiltonian-eoh">Evolution of Hamiltonian (EOH)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#quantum-phase-estimation-qpe">Quantum Phase Estimation (QPE)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#iterative-quantum-phase-estimation-iqpe">Iterative Quantum Phase Estimation (IQPE)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#amplitude-estimation-algorithm">Amplitude Estimation Algorithm</a></li>
<li class="toctree-l5"><a class="reference internal" href="#quantum-grover-search">Quantum Grover Search</a></li>
<li class="toctree-l5"><a class="reference internal" href="#support-vector-machine-quantum-kernel-qsvm-kernel">Support Vector Machine Quantum Kernel (QSVM Kernel)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#support-vector-machine-variational-qsvm-variational">Support Vector Machine Variational (QSVM Variational)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#classical-reference-algorithms">Classical Reference Algorithms</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#exact-eigensolver">Exact Eigensolver</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cplex-ising">CPLEX Ising</a></li>
<li class="toctree-l5"><a class="reference internal" href="#support-vector-machine-radial-basis-function-kernel-svm-classical">Support Vector Machine Radial Basis Function Kernel (SVM Classical)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="optimizers.html">Optimizers</a></li>
<li class="toctree-l3"><a class="reference internal" href="variational_forms.html">Variational Forms</a></li>
<li class="toctree-l3"><a class="reference internal" href="oracles.html">Oracles</a></li>
<li class="toctree-l3"><a class="reference internal" href="iqfts.html">Inverse Quantum Fourier Transforms</a></li>
<li class="toctree-l3"><a class="reference internal" href="initial_states.html">Initial States</a></li>
<li class="toctree-l3"><a class="reference internal" href="feature_maps.html">Feature Maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="qiskit_aqua.html">Aqua SDK Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="aqua_ai.html">Aqua Artificial Intelligence</a></li>
<li class="toctree-l2"><a class="reference internal" href="aqua_optimization.html">Aqua Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="aqua_finance.html">Aqua Finance</a></li>
<li class="toctree-l2"><a class="reference internal" href="aqua_tutorials.html">Aqua Tutorials</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="extending.html"
                        title="previous chapter">Contributing to Aqua</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="optimizers.html"
                        title="next chapter">Optimizers</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/algorithms.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="algorithms">
<span id="id1"></span><h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h1>
<p>Aqua is an extensible collection of algorithms and utilities for use with quantum computers to
carry out research and investigate how to solve problems using near-term
quantum applications on short depth circuits. The applications can span
different domains. Aqua uses
<a class="reference external" href="https://www.qiskit.org/terra">Terra</a> for the generation, compilation and execution
of the quantum circuits modeling the specific problems.</p>
<p>The following <a class="reference external" href="#quantum-algorithms">quantum algorithms</a> are part of Aqua:</p>
<ul class="simple">
<li><a class="reference internal" href="#variational-quantum-eigensolver-vqe"><span class="std std-ref">Variational Quantum Eigensolver (VQE)</span></a></li>
<li><a class="reference internal" href="#quantum-approximate-optimization-algorithm-qaoa"><span class="std std-ref">Quantum Approximate Optimization Algorithm (QAOA)</span></a></li>
<li><a class="reference internal" href="#evolution-of-hamiltonian-eoh"><span class="std std-ref">Evolution of Hamiltonian (EOH)</span></a></li>
<li><a class="reference internal" href="#quantum-phase-estimation-qpe"><span class="std std-ref">Quantum Phase Estimation (QPE)</span></a></li>
<li><a class="reference internal" href="#iterative-quantum-phase-estimation-iqpe"><span class="std std-ref">Iterative Quantum Phase Estimation (IQPE)</span></a></li>
<li><span class="xref std std-ref">Amplitude Estimation</span></li>
<li><a class="reference internal" href="#quantum-grover-search"><span class="std std-ref">Quantum Grover Search</span></a></li>
<li><a class="reference internal" href="#support-vector-machine-quantum-kernel-qsvm-kernel"><span class="std std-ref">Support Vector Machine Quantum Kernel (QSVM Kernel)</span></a></li>
<li><a class="reference internal" href="#support-vector-machine-variational-qsvm-variational"><span class="std std-ref">Support Vector Machine Variational (QSVM Variational)</span></a></li>
</ul>
<p>Aqua includes  also some <a class="reference external" href="#classical-reference-algorithms">classical algorithms</a>
for generating reference values. This feature of Aqua may be
useful to quantum algorithm researchers interested in generating, comparing and contrasting
results in the near term while experimenting with, developing and testing
quantum algorithms:</p>
<ul class="simple">
<li><a class="reference internal" href="#exact-eigensolver"><span class="std std-ref">Exact Eigensolver</span></a></li>
<li><a class="reference internal" href="#cplex-ising"><span class="std std-ref">CPLEX Ising</span></a></li>
<li><a class="reference internal" href="#support-vector-machine-radial-basis-function-kernel-svm-classical"><span class="std std-ref">Support Vector Machine Radial Basis Function Kernel (SVM Classical)</span></a></li>
</ul>
<div class="topic">
<p class="topic-title first">Extending the Algorithm Library</p>
<p>Algorithms and many of the components they use have been designed to be
pluggable. A new algorithm may be developed according to the specific Application Programming Interface (API)
provided by Aqua, and by simply adding its code to the collection of existing
algorithms, that new algorithm  will be immediately recognized via dynamic lookup,
and made available for use within the framework of Aqua.
Specifically, to develop and deploy any new algorithm, the new algorithm class should derive from the <code class="docutils literal notranslate"><span class="pre">QuantumAlgorithm</span></code> class.
Along with any supporting  module, for immediate dynamic discovery, the new algorithm class
can simply be placed in an appropriate folder in the <code class="docutils literal notranslate"><span class="pre">qiskit_aqua\algorithms</span></code> directory, just like the
existing algorithms.  Aqua also allows for
<a class="reference internal" href="extending.html#aqua-dynamically-discovered-components"><span class="std std-ref">Dynamically Discovered Components</span></a>: new components can register themselves
as Aqua extensions and be dynamically discovered at run time independent of their
location in the file system.
This is done in order to encourage researchers and
developers interested in
<a class="reference internal" href="extending.html#aqua-extending"><span class="std std-ref">Contributing to Aqua</span></a> to extend the Aqua framework with their novel research contributions.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Section <a class="reference internal" href="extending.html#aqua-extending"><span class="std std-ref">Contributing to Aqua</span></a> provides more
details on how to extend Aqua with new components.</p>
</div>
<div class="section" id="quantum-algorithms">
<span id="id2"></span><h2>Quantum Algorithms<a class="headerlink" href="#quantum-algorithms" title="Permalink to this headline">¶</a></h2>
<p>In this section, we describe the quantum algorithms currently available in Aqua.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Aqua requires associating a quantum device or simulator to any experiment that uses a quantum
algorithm.  This is done by configuring the <code class="docutils literal notranslate"><span class="pre">&quot;backend&quot;</span></code> section of the experiment to be run.
Consult the documentation on the <a class="reference internal" href="execution.html#aqua-input-file"><span class="std std-ref">Input File</span></a> for more details.</p>
</div>
<div class="section" id="variational-quantum-eigensolver-vqe">
<span id="vqe"></span><h3>Variational Quantum Eigensolver (VQE)<a class="headerlink" href="#variational-quantum-eigensolver-vqe" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://arxiv.org/abs/1304.3061">VQE</a> is a hybrid algorithm that uses
the variational approach and interleaves quantum and classical computations in order to find
the minimum eigenvalue of the Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> of a given system.
An instance of VQE requires defining two algorithmic subcomponents:
a trial function from Aqua’s <a class="reference internal" href="variational_forms.html#variational-forms"><span class="std std-ref">Variational Forms</span></a> library, and a classical optimizer
from Aqua’s <a class="reference internal" href="optimizers.html#optimizers"><span class="std std-ref">Optimizers</span></a> library.  An initial state from Aqua’s
<a class="reference internal" href="initial_states.html#initial-states"><span class="std std-ref">Initial States</span></a> library may be supplied too in order to
define the starting state for the trial function.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Refer to the documentation of <a class="reference internal" href="variational_forms.html#variational-forms"><span class="std std-ref">Variational Forms</span></a>, <a class="reference internal" href="optimizers.html#optimizers"><span class="std std-ref">Optimizers</span></a>
and <a class="reference internal" href="initial_states.html#initial-states"><span class="std std-ref">Initial States</span></a> for more details.</p>
</div>
<p>Additionally, VQE can be configured with the following parameters:</p>
<ul>
<li><p class="first">A <code class="docutils literal notranslate"><span class="pre">str</span></code> value indicating the mode used by the <code class="docutils literal notranslate"><span class="pre">Operator</span></code> class for the computation:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">operator_mode</span> <span class="p">:</span> <span class="s2">&quot;matrix&quot;</span> <span class="o">|</span> <span class="s2">&quot;paulis&quot;</span> <span class="o">|</span> <span class="s2">&quot;grouped_paulis&quot;</span>
</pre></div>
</div>
<p>If no value for <code class="docutils literal notranslate"><span class="pre">operator_mode</span></code> is specified, the default is <code class="docutils literal notranslate"><span class="pre">&quot;matrix&quot;</span></code>.</p>
</li>
<li><p class="first">The initial point for the search of the minimum eigenvalue:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initial_point</span> <span class="p">:</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
<p>An optional list of <code class="docutils literal notranslate"><span class="pre">float</span></code> values  may be provided as the starting point for the search of the minimum eigenvalue.
This feature is particularly useful when there are reasons to believe that the
solution point is close to a particular point, which can then be provided as the preferred initial point.  As an example,
when building the dissociation profile of a molecule, it is likely that
using the previous computed optimal solution as the starting initial point for the next interatomic distance is going
to reduce the number of iterations necessary for the variational algorithm to converge.  Aqua provides
<a class="reference external" href="https://github.com/Qiskit/aqua-tutorials/blob/master/chemistry/h2_vqe_initial_point.ipynb">a tutorial detailing this use case</a>.</p>
<p>The length of the <code class="docutils literal notranslate"><span class="pre">initial_point</span></code> list value must match the number of the parameters expected by the variational form being used.
If the user does not supply a preferred initial point, then VQE will look to the variational form for a preferred value.
If the variational form returns <code class="docutils literal notranslate"><span class="pre">None</span></code>,
then a random point will be generated within the parameter bounds set, as per above.
If the variational form provides <code class="docutils literal notranslate"><span class="pre">None</span></code> as the lower bound, then VQE
will default it to <span class="math notranslate nohighlight">\(-2\pi\)</span>; similarly, if the variational form returns <code class="docutils literal notranslate"><span class="pre">None</span></code> as the upper bound, the default value will be <span class="math notranslate nohighlight">\(2\pi\)</span>.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to VQE declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which Aqua dynamically discovers and loads it,
is <code class="docutils literal notranslate"><span class="pre">VQE</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, VQE supports the <code class="docutils literal notranslate"><span class="pre">energy</span></code> and <code class="docutils literal notranslate"><span class="pre">ising</span></code> problems.</p>
</div>
</div>
<div class="section" id="quantum-approximate-optimization-algorithm-qaoa">
<span id="qaoa"></span><h3>Quantum Approximate Optimization Algorithm (QAOA)<a class="headerlink" href="#quantum-approximate-optimization-algorithm-qaoa" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://arxiv.org/abs/1411.4028">QAOA</a> is a well-known algorithm for finding approximate solutions to
combinatorial-optimization problems.
The QAOA implementation in Aqua directly uses <a class="reference external" href="#variational-quantum-eigensolver-vqe">VQE</a> for its general hybrid optimization structure.
However, unlike VQE, which can be configured with arbitrary variational forms,
QAOA uses its own fine-tuned variational form, which comprises <span class="math notranslate nohighlight">\(p\)</span> parameterized global <span class="math notranslate nohighlight">\(x\)</span> rotations and
<span class="math notranslate nohighlight">\(p\)</span> different parameterizations of the problem hamiltonian.
As a result, unlike VQE, QAOA does not need to have a variational form specified as an input parameter,
and is configured mainly by a single integer parameter, <code class="docutils literal notranslate"><span class="pre">p</span></code>,
which dictates the depth of the variational form, and thus affects the approximation quality.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Consult the documentation on <a class="reference internal" href="optimizers.html#optimizers"><span class="std std-ref">Optimizers</span></a> for more details.</p>
</div>
<p>In summary, QAOA can be configured with the following parameters:</p>
<ul>
<li><p class="first">A <code class="docutils literal notranslate"><span class="pre">str</span></code> value indicating the mode used by the <code class="docutils literal notranslate"><span class="pre">Operator</span></code> class for the computation:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">operator_mode</span> <span class="p">:</span> <span class="s2">&quot;matrix&quot;</span> <span class="o">|</span> <span class="s2">&quot;paulis&quot;</span> <span class="o">|</span> <span class="s2">&quot;grouped_paulis&quot;</span>
</pre></div>
</div>
<p>If no value for <code class="docutils literal notranslate"><span class="pre">operator_mode</span></code> is specified, the default is <code class="docutils literal notranslate"><span class="pre">&quot;matrix&quot;</span></code>.</p>
</li>
<li><p class="first">A positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value configuring the QAOA variational form depth, as discussed above:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>This has to be a positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value.  The default is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</li>
<li><p class="first">The initial point for the search of the minimum eigenvalue:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initial_point</span> <span class="p">:</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
<p>An optional list of <span class="math notranslate nohighlight">\(2p\)</span> <code class="docutils literal notranslate"><span class="pre">float</span></code> values  may be provided as the starting <code class="docutils literal notranslate"><span class="pre">beta</span></code> and <code class="docutils literal notranslate"><span class="pre">gamma</span></code> parameters
(as identically named in the original <a class="reference external" href="https://arxiv.org/abs/1411.4028">QAOA paper</a>) for the QAOA variational form.
If such list is not provided, QAOA will simply start with the all-zero vector.</p>
</li>
</ul>
<p>Similar to VQE, an optimizer may also be specified.</p>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to QAOA declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>,
by which Aqua dynamically discovers and loads it,
is <code class="docutils literal notranslate"><span class="pre">QAOA.Variational</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, QAOA supports the <code class="docutils literal notranslate"><span class="pre">ising</span></code> problem.</p>
</div>
</div>
<div class="section" id="evolution-of-hamiltonian-eoh">
<span id="dynamics"></span><h3>Evolution of Hamiltonian (EOH)<a class="headerlink" href="#evolution-of-hamiltonian-eoh" title="Permalink to this headline">¶</a></h3>
<p>EOH provides the lower-level building blocks for simulating
universal quantum systems. For any given quantum system that can be
decomposed into local interactions (for example, a global hamiltonian as
the weighted sum of several Pauli spin operators), the local
interactions can then be used to approximate the global quantum system
via, for example, Lloyd’s method or Trotter-Suzuki decomposition.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This algorithm only supports the local state vector simulator.</p>
</div>
<p>EOH can be configured with the following parameter settings:</p>
<ul>
<li><p class="first">Evolution time:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">evo_time</span> <span class="p">:</span> <span class="nb">float</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">float</span></code> value is expected.  The minimum value is <code class="docutils literal notranslate"><span class="pre">0.0</span></code>.  The default value is <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</p>
</li>
<li><p class="first">The evolution mode of the computation:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">evo_mode</span> <span class="o">=</span> <span class="s2">&quot;matrix&quot;</span> <span class="o">|</span> <span class="s2">&quot;circuit&quot;</span>
</pre></div>
</div>
<p>Two <code class="docutils literal notranslate"><span class="pre">str</span></code> values are permitted: <code class="docutils literal notranslate"><span class="pre">&quot;matrix&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;circuit&quot;</span></code>, with <code class="docutils literal notranslate"><span class="pre">&quot;circuit&quot;</span></code> being the default.</p>
</li>
<li><p class="first">The number of time slices:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_time_slices</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>This has to be a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value.  The default is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</li>
<li><p class="first">Paulis grouping mode:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">paulis_grouping</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span> <span class="o">|</span> <span class="s2">&quot;random&quot;</span>
</pre></div>
</div>
<p>Two <code class="docutils literal notranslate"><span class="pre">str</span></code> values are permitted: <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;random&quot;</span></code>, with <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> being the default and indicating
that the Paulis should be grouped.</p>
</li>
<li><p class="first">The expansion mode:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expansion_mode</span> <span class="o">=</span> <span class="s2">&quot;trotter&quot;</span> <span class="o">|</span> <span class="s2">&quot;suzuki&quot;</span>
</pre></div>
</div>
<p>Two <code class="docutils literal notranslate"><span class="pre">str</span></code> values are permitted: <code class="docutils literal notranslate"><span class="pre">&quot;trotter&quot;</span></code> (Lloyd’s method) or <code class="docutils literal notranslate"><span class="pre">&quot;suzuki&quot;</span></code> (for Trotter-Suzuki expansion),
with  <code class="docutils literal notranslate"><span class="pre">&quot;trotter&quot;</span></code> being the default one.</p>
</li>
<li><p class="first">The expansion order:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expansion_order</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>This parameter sets the Trotter-Suzuki expansion order.  A positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value is expected.  The default value is <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to EOH declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">EOH</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, EOH supports the <code class="docutils literal notranslate"><span class="pre">eoh</span></code> problem.</p>
</div>
</div>
<div class="section" id="quantum-phase-estimation-qpe">
<span id="qpe"></span><h3>Quantum Phase Estimation (QPE)<a class="headerlink" href="#quantum-phase-estimation-qpe" title="Permalink to this headline">¶</a></h3>
<p>QPE (also sometimes abbreviated
as PEA, for <em>Phase Estimation Algorithm</em>), takes two quantum registers, <em>control</em> and <em>target</em>, where the
control consists of several qubits initially put in uniform
superposition, and the target a set of qubits prepared in an eigenstate
(or, oftentimes, a guess of the eigenstate) of the unitary operator of
a quantum system. QPE then evolves the target under the control using
<a class="reference internal" href="#dynamics"><span class="std std-ref">Evolution of Hamiltonian (EOH)</span></a> on the unitary operator. The information of the
corresponding eigenvalue is then <em>kicked-back</em> into the phases of the
control register, which can then be deconvoluted by an Inverse Quantum
Fourier Transform (IQFT), and measured for read-out in binary decimal
format.  QPE also requires a reasonably good estimate of the eigen wave function
to start the process. For example, when estimating molecular ground energies,
the <a class="reference internal" href="initial_states.html#id2"><span class="std std-ref">Hartree-Fock</span></a> method could be used to provide such trial eigen wave
functions.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Consult the documentation on <a class="reference internal" href="iqfts.html#iqfts"><span class="std std-ref">Inverse Quantum Fourier Transforms</span></a> and <a class="reference internal" href="initial_states.html#initial-states"><span class="std std-ref">Initial States</span></a>
for more details.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This algorithm does not support the local state vector simulator.</p>
</div>
<p>In addition to requiring an IQFT and an initial state as part of its
configuration, QPE also exposes the following parameter settings:</p>
<ul>
<li><p class="first">The number of time slices:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_time_slices</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>This has to be a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value.  The default value is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</li>
<li><p class="first">Paulis grouping mode:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">paulis_grouping</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span> <span class="o">|</span> <span class="s2">&quot;random&quot;</span>
</pre></div>
</div>
<p>Two string values are permitted: <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;random&quot;</span></code>, with <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code>
being the default and indicating that the Paulis should be grouped.</p>
</li>
<li><p class="first">The expansion mode:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expansion_mode</span> <span class="o">=</span> <span class="s2">&quot;trotter&quot;</span> <span class="o">|</span> <span class="s2">&quot;suzuki&quot;</span>
</pre></div>
</div>
<p>Two <code class="docutils literal notranslate"><span class="pre">str</span></code> values are permitted: <code class="docutils literal notranslate"><span class="pre">&quot;trotter&quot;</span></code> (Lloyd’s method) or <code class="docutils literal notranslate"><span class="pre">&quot;suzuki&quot;</span></code> (for Trotter-Suzuki expansion),
with  <code class="docutils literal notranslate"><span class="pre">&quot;trotter&quot;</span></code> being the default one.</p>
</li>
<li><p class="first">The expansion order:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expansion_order</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>This parameter sets the Trotter-Suzuki expansion order.  A positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value is expected.  The default value is <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</li>
<li><p class="first">The number of ancillae:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_ancillae</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>This parameter sets the number of ancillary qubits to be used by QPE.  A positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value is expected.
The default value is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to QPE declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">QPE</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, QPE supports the <code class="docutils literal notranslate"><span class="pre">energy</span></code> problem.</p>
</div>
</div>
<div class="section" id="iterative-quantum-phase-estimation-iqpe">
<span id="iqpe"></span><h3>Iterative Quantum Phase Estimation (IQPE)<a class="headerlink" href="#iterative-quantum-phase-estimation-iqpe" title="Permalink to this headline">¶</a></h3>
<p>IQPE, as its name
suggests, iteratively computes the phase so as to require fewer qubits.
It takes in the same set of parameters as <a class="reference external" href="#quantum-phase-estimation-qpe">QPE</a>, except for the number of
ancillary qubits <code class="docutils literal notranslate"><span class="pre">num_ancillae</span></code>, which is replaced by
<code class="docutils literal notranslate"><span class="pre">num_iterations</span></code> (a positive <code class="docutils literal notranslate"><span class="pre">int</span></code>, also defaulted to <code class="docutils literal notranslate"><span class="pre">1</span></code>), and for the fact that an
Inverse Quantum Fourier Transform (IQFT) is not used for IQPE.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This algorithm does not support the local state vector simulator.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more details, please see <a class="reference external" href="https://arxiv.org/abs/quant-ph/0610214">arXiv:quant-ph/0610214</a>.</p>
</div>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to IQPE declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">IQPE</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, IQPE supports the <code class="docutils literal notranslate"><span class="pre">energy</span></code> problem.</p>
</div>
</div>
<div class="section" id="amplitude-estimation-algorithm">
<span id="ae"></span><h3>Amplitude Estimation Algorithm<a class="headerlink" href="#amplitude-estimation-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The <em>Amplitude Estimation</em> algorithm can be used to estimate
the amplitude of the <a href="#id3"><span class="problematic" id="id4">|</span></a>1&gt; outcome of a unitary operator
corresponding to a Bernoulli distribution.
With the uncertainty problem,
as well as the number of ancillary evaluation qubits, specified,
Amplitude Estimation internally builds a <em>Quantum Phase Estimation</em> circuit
that efficiently carries out the estimation task
with a quadratic speedup compared to the classical Monte Carlo method.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p>Consult the documentation on <a class="reference internal" href="#qpe"><span class="std std-ref">Quantum Phase Estimation (QPE)</span></a> for more details.</p>
<p class="last">Also, see <a class="reference external" href="https://arxiv.org/abs/1806.06893">arXiv:1806.06893</a> for more details on Amplitude Estimation
as well as its applications on finance problems.</p>
</div>
<p>In addition to relying on a <code class="docutils literal notranslate"><span class="pre">PhaseEstimation</span></code> component
for building, well, the Quantum Phase Estimation circuit,
the Amplitude Estimation algorithm expects the following inputs:</p>
<ul>
<li><p class="first">The number of evaluation qubits:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_eval_qubits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>This has to be a positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value.</p>
</li>
<li><p class="first">The uncertainty problem:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_factory</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">CircuitFactory</span></code> object that represents the uncertainty problem.</p>
</li>
<li><p class="first">The optional problem unitary:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_factory</span>
</pre></div>
</div>
<p>An optional <code class="docutils literal notranslate"><span class="pre">CircuitFactory</span></code> object that represents the problem unitary,
which, if left unspecified, will be automatically constructed from the <code class="docutils literal notranslate"><span class="pre">a_factory</span></code>.</p>
</li>
<li><p class="first">The Inverse Quantum Fourier Transform component:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iqft</span>
</pre></div>
</div>
<p>The Inverse Quantum Fourier Transform pluggable component
that’s to be used to configure the <code class="docutils literal notranslate"><span class="pre">PhaseEstimation</span></code> component.
The standard iqft will be used by default if left None.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to Amplitude Estimation declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">AmplitudeEstimation</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, Amplitude Estimation supports the <code class="docutils literal notranslate"><span class="pre">uncertainty</span></code> problem.</p>
</div>
</div>
<div class="section" id="quantum-grover-search">
<span id="grover"></span><h3>Quantum Grover Search<a class="headerlink" href="#quantum-grover-search" title="Permalink to this headline">¶</a></h3>
<p>Grover’s Search is a well known quantum algorithm for searching through
unstructured collections of records for particular targets with quadratic
speedups.</p>
<p>Given a set <span class="math notranslate nohighlight">\(X\)</span> of <span class="math notranslate nohighlight">\(N\)</span> elements
<span class="math notranslate nohighlight">\(X=\{x_1,x_2,\ldots,x_N\}\)</span> and a boolean function <span class="math notranslate nohighlight">\(f : X \rightarrow \{0,1\}\)</span>,
the goal on an <em>unstructured-search problem</em> is to find an
element <span class="math notranslate nohighlight">\(x^* \in X\)</span> such that <span class="math notranslate nohighlight">\(f(x^*)=1\)</span>.
Unstructured  search  is  often  alternatively  formulated  as  a  database  search  problem, in
which, given a database, the goal is to find in it an item that meets some specification.
The search is called <em>unstructured</em> because there are no guarantees as to how the
database is ordered.  On a sorted database, for instance, one could perform
binary  search  to  find  an  element in <span class="math notranslate nohighlight">\(\mathbb{O}(\log N)\)</span> worst-case time.
Instead, in an unstructured-search problem, there is no  prior knowledge about the contents
of the database.  With classical circuits, there is no alternative but
to perform a linear number of queries to find the target element.
Conversely, Grover’s Search algorithm allows to solve the unstructured-search problem
on a quantum computer in <span class="math notranslate nohighlight">\(\mathcal{O}(\sqrt{N})\)</span> queries.</p>
<p>All that is needed for carrying out a search is an oracle from Aqua’s <a class="reference internal" href="oracles.html#oracles"><span class="std std-ref">Oracles</span></a> library for
specifying the search criterion, which basically indicates a hit or miss
for any given record.  More formally, an <em>oracle</em> <span class="math notranslate nohighlight">\(O_f\)</span> is an object implementing a boolean function
<span class="math notranslate nohighlight">\(f\)</span> as specified above.  Given an input <span class="math notranslate nohighlight">\(x \in X\)</span>, <span class="math notranslate nohighlight">\(O_f\)</span> returns <span class="math notranslate nohighlight">\(f(x)\)</span>.  The
details of how <span class="math notranslate nohighlight">\(O_f\)</span> works are unimportant; Grover’s search algorithm treats an oracle as a black
box.  Currently, Aqua provides the satisfiability (SAT) oracle
implementation, which takes as input an SAT problem in
<a class="reference external" href="http://www.satcompetition.org/2009/format-benchmarks2009.html">DIMACS CNF
format</a>
and constructs the corresponding quantum circuit.  Oracles are treated as pluggable components
in Aqua; researchers interested in <a class="reference internal" href="extending.html#aqua-extending"><span class="std std-ref">Contributing to Aqua</span></a> can design and implement new
oracles and extend Aqua’s oracle library.</p>
<p>Grover is configured with the following parameter settings:</p>
<ul>
<li><p class="first">Number of iterations:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>For the conventional Grover’s search algorithm, the parameter <code class="docutils literal notranslate"><span class="pre">num_iterations</span></code> is used to specify
how many times the marking and reflection phase sub-circuit is repeated to amplify the amplitude(s) of the target(s).
A positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value is expected. The default value is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</li>
<li><p class="first">Incremental mode flag:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Incremental</span> <span class="o">=</span> <span class="kc">False</span> <span class="o">|</span> <span class="kc">True</span>
</pre></div>
</div>
<p>When run in <code class="docutils literal notranslate"><span class="pre">incremental</span></code> mode, the search task will be carried out by using successive circuits built using incrementally higher
number of iterations for the repetition of the amplitude amplification until a target is found
or the maximal number <span class="math notranslate nohighlight">\(\log N\)</span> (<span class="math notranslate nohighlight">\(N\)</span> being the total number of elements in the set from the oracle used) of iterations is reached.
This is a boolean flag defaulted to <code class="docutils literal notranslate"><span class="pre">False</span></code>;
when set <code class="docutils literal notranslate"><span class="pre">True</span></code>, the other parameter <code class="docutils literal notranslate"><span class="pre">num_iterations</span></code> will be ignored.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to Quantum Grover Search declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">Grover</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, Grover’s Search algorithm supports the <code class="docutils literal notranslate"><span class="pre">search</span></code> problem.</p>
</div>
</div>
<div class="section" id="support-vector-machine-quantum-kernel-qsvm-kernel">
<span id="svm-q-kernel"></span><h3>Support Vector Machine Quantum Kernel (QSVM Kernel)<a class="headerlink" href="#support-vector-machine-quantum-kernel-qsvm-kernel" title="Permalink to this headline">¶</a></h3>
<p>Classification algorithms and methods for machine learning are essential
for pattern recognition and data mining applications. Well known
techniques, such as support vector machines or neural networks, have
blossomed over the last two decades as a result of the spectacular
advances in classical hardware computational capabilities and speed.
This progress in computer power made it possible to apply techniques
theoretically developed towards the middle of the XX century on
classification problems that soon became increasingly challenging.</p>
<p>A key concept in classification methods is that of a kernel. Data cannot
typically be separated by a hyperplane in its original space. A common
technique used to find such a hyperplane consists on applying a
non-linear transformation function to the data. This function is called
a <em>feature map</em>, as it transforms the raw features, or measurable
properties, of the phenomenon or subject under study. Classifying in
this new feature space – and, as a matter of fact, also in any other
space, including the raw original one – is nothing more than seeing how
close data points are to each other. This is the same as computing the
inner product for each pair of data in the set. In fact we do not need
to compute the non-linear feature map for each datum, but only the inner
product of each pair of data points in the new feature space. This
collection of inner products is called the <em>kernel</em> and it is perfectly
possible to have feature maps that are hard to compute but whose kernels
are not.</p>
<p>The QSVM Kernel algorithm applies to classification problems that
require a feature map for which computing the kernel is not efficient
classically. This means that the required computational resources are
expected to scale exponentially with the size of the problem.
QSVM Kernel uses a Quantum processor to solve this problem by a direct
estimation of the kernel in the feature space. The method used falls in
the category of what is called <em>supervised learning</em>, consisting of a
<em>training phase</em> (where the kernel is calculated and the support vectors
obtained) and a <em>test or classification phase</em> (where new labelless data
is classified according to the solution found in the training phase).</p>
<p>QSVM Kernel can be configured with a <code class="docutils literal notranslate"><span class="pre">bool</span></code> parameter, indicating
whether or not to print additional information when the algorithm is running:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">print_info</span> <span class="p">:</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>The default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to QSVM Kernel declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">QSVM.Kernel</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, QSVM Kernel  supports the <code class="docutils literal notranslate"><span class="pre">svm_classification</span></code> problem.</p>
</div>
</div>
<div class="section" id="support-vector-machine-variational-qsvm-variational">
<span id="svm-variational"></span><h3>Support Vector Machine Variational (QSVM Variational)<a class="headerlink" href="#support-vector-machine-variational-qsvm-variational" title="Permalink to this headline">¶</a></h3>
<p>Just like QSVM Kernel, the QSVM Variational algorithm applies to
classification problems that require a feature map for which computing
the kernel is not efficient classically. QSVM Variational uses the variational method to solve such
problems in a quantum processor.  Specifically, it optimizes a
parameterized quantum circuit to provide a solution that cleanly
separates the data.</p>
<p>QSVM Variational can be configured with the following parameters:</p>
<ul>
<li><p class="first">The depth of the variational circuit to be optimized:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">circuit_depth</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>An integer value greater than or equal to <code class="docutils literal notranslate"><span class="pre">3</span></code> is expected.  The default is <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
</li>
<li><p class="first">A Boolean indicating whether or not to print additional information when the algorithm is running:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">print_info</span> <span class="p">:</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">bool</span></code> value is expected.  The default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to QSVM Variational declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">QSVM.Variational</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, QSVM Variational  supports the <code class="docutils literal notranslate"><span class="pre">svm_classification</span></code> problem.</p>
</div>
</div>
</div>
<div class="section" id="classical-reference-algorithms">
<span id="id5"></span><h2>Classical Reference Algorithms<a class="headerlink" href="#classical-reference-algorithms" title="Permalink to this headline">¶</a></h2>
<p>In this section, we describe the classical algorithms currently available in Aqua.
While these algorithms do not use a quantum device or simulator, and rely on
purely classical approaches, they may be useful in the
near term to generate reference values while experimenting with, developing and testing quantum
algorithms.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Aqua prevents associating a quantum device or simulator to any experiment that uses a classical
algorithm.  The <code class="docutils literal notranslate"><span class="pre">&quot;backend&quot;</span></code> section of an experiment to be conducted via a classical algorithm is
disabled.</p>
</div>
<div class="section" id="exact-eigensolver">
<span id="id6"></span><h3>Exact Eigensolver<a class="headerlink" href="#exact-eigensolver" title="Permalink to this headline">¶</a></h3>
<p>Exact Eigensolver computes up to the first <span class="math notranslate nohighlight">\(k\)</span> eigenvalues of a complex square matrix of dimension
<span class="math notranslate nohighlight">\(n \times n\)</span>, with <span class="math notranslate nohighlight">\(k \leq n\)</span>.
It can be configured with an <code class="docutils literal notranslate"><span class="pre">int</span></code> parameter <code class="docutils literal notranslate"><span class="pre">k</span></code> indicating the number of eigenvalues to compute:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="n">n</span>
</pre></div>
</div>
<p>Specifically, the value of this parameter must be an <code class="docutils literal notranslate"><span class="pre">int</span></code> value <code class="docutils literal notranslate"><span class="pre">k</span></code> in the range <span class="math notranslate nohighlight">\([1,n]\)</span>. The default is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to Exact Eigensolver declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">ExactEigensolver</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, Exact Eigensolver supports the <code class="docutils literal notranslate"><span class="pre">energy</span></code>, <code class="docutils literal notranslate"><span class="pre">ising</span></code> and <code class="docutils literal notranslate"><span class="pre">excited_states</span></code>  problems.</p>
</div>
</div>
<div class="section" id="cplex-ising">
<span id="cplex"></span><h3>CPLEX Ising<a class="headerlink" href="#cplex-ising" title="Permalink to this headline">¶</a></h3>
<p>This algorithm uses the <a class="reference external" href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.studio.help/Optimization_Studio/topics/COS_home.html">IBM ILOG CPLEX Optimization
Studio</a>,
which should be installed along with its <a class="reference external" href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html">Python API</a>
for this algorithm to be operational. This algorithm currently
supports computing the energy of an Ising model Hamiltonian.</p>
<p>CPLEX Ising can be configured with the following parameters:</p>
<ul>
<li><p class="first">A time limit in seconds for the execution:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">timelimit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>A positive <code class="docutils literal notranslate"><span class="pre">int</span></code> value is expected.  The default value is <cite>600</cite>.</p>
</li>
<li><p class="first">The number of threads that CPLEX uses:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">thread</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>A non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value is expected. Setting <code class="docutils literal notranslate"><span class="pre">thread</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code> lets CPLEX decide the number of threads to allocate, but this may
not be ideal for small problems.  Any value
greater than <code class="docutils literal notranslate"><span class="pre">0</span></code> specifically sets the thread count.  The default value is <code class="docutils literal notranslate"><span class="pre">1</span></code>, which is ideal for small problems.</p>
</li>
<li><p class="first">Decides what CPLEX reports to the screen and records in a log during mixed integer optimization (MIP).</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">display</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">5</span>
</pre></div>
</div>
<p>An <code class="docutils literal notranslate"><span class="pre">int</span></code> value between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code> is expected.
The amount of information displayed increases with increasing values of this parameter.
By default, this value is set to <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to CPLEX Ising declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">CPLEX.Ising</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, CPLEX supports the <code class="docutils literal notranslate"><span class="pre">ising</span></code> problem.</p>
</div>
</div>
<div class="section" id="support-vector-machine-radial-basis-function-kernel-svm-classical">
<h3>Support Vector Machine Radial Basis Function Kernel (SVM Classical)<a class="headerlink" href="#support-vector-machine-radial-basis-function-kernel-svm-classical" title="Permalink to this headline">¶</a></h3>
<p>SVM Classical uses a classical approach to experiment with feature map classification
problems.
SVM Classical can be configured with a <code class="docutils literal notranslate"><span class="pre">bool</span></code> parameter,
indicating whether or not to print additional information when the algorithm is running:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">print_info</span> <span class="p">:</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>The default value for this parameter is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="topic">
<p class="topic-title first">Declarative Name</p>
<p>When referring to SVM Classical declaratively inside Aqua, its code <code class="docutils literal notranslate"><span class="pre">name</span></code>, by which
Aqua dynamically discovers and loads it, is <code class="docutils literal notranslate"><span class="pre">SVM</span></code>.</p>
</div>
<div class="topic">
<p class="topic-title first">Problems Supported</p>
<p>In Aqua, SVM Classical supports the <code class="docutils literal notranslate"><span class="pre">svm_classification</span></code> problem.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="optimizers.html" title="Optimizers"
             >next</a> |</li>
        <li class="right" >
          <a href="extending.html" title="Contributing to Aqua"
             >previous</a> |</li>
<li id="toc-toggle">
<a class="btn btn-primary" role="button" data-toggle="collapse"
   href=".sphinxsidebar" aria-expanded="false" aria-controls="collapseExample">
  TOC</a> |
</li>

        <li class="nav-item nav-item-0"><a href="index.html">Qiskit Aqua 0.4.0 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="aqua.html" >Qiskit Aqua</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="library.html" >Aqua: A Library of Quantum Algorithms</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018 IBM.
      Last updated on 2018/12/14.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
  </body>
</html>